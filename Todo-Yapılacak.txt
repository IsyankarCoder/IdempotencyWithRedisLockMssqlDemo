SÃ¼per ğŸ‘Œ ÅŸimdi gerÃ§ek production seviyesi bir Ã§Ã¶zÃ¼m yapÄ±yoruz:

ğŸ”¥ Redis tamamen down ise
30 saniye boyunca Redisâ€™i otomatik bypass edelim
Her requestâ€™te exception yemeyelim

Bu mini Circuit Breaker olacak.

ğŸ¯ MantÄ±k

Normal akÄ±ÅŸ:

Redis Ã§alÄ±ÅŸÄ±yor â†’ lock & cache aktif

Redis hata verirse:

Exception â†’
Circuit OPEN â†’
30 saniye Redis tamamen bypass â†’
Sonra HALF-OPEN test â†’
BaÅŸarÄ±lÄ±ysa tekrar CLOSED
ğŸ§  State Diagram
CLOSED  â†’ (Redis error) â†’  OPEN
OPEN    â†’ (30 sn doldu)  â†’  HALF-OPEN
HALF    â†’ (baÅŸarÄ±lÄ±)     â†’  CLOSED
HALF    â†’ (fail)         â†’  OPEN
âœ… 1ï¸âƒ£ Mini Circuit Breaker Service

Thread-safe, lightweight:

public class RedisCircuitBreaker
{
    private readonly TimeSpan _breakDuration = TimeSpan.FromSeconds(30);

    private DateTime _lastFailureTime = DateTime.MinValue;
    private volatile bool _isOpen = false;

    public bool IsOpen()
    {
        if (!_isOpen)
            return false;

        // Break sÃ¼resi dolmuÅŸ mu?
        if (DateTime.UtcNow - _lastFailureTime > _breakDuration)
        {
            _isOpen = false; // HALF-OPEN gibi davran
            return false;
        }

        return true;
    }

    public void RecordFailure()
    {
        _isOpen = true;
        _lastFailureTime = DateTime.UtcNow;
    }

    public void RecordSuccess()
    {
        _isOpen = false;
    }
}
âœ… 2ï¸âƒ£ DI KaydÄ±

Program.cs:

builder.Services.AddSingleton<RedisCircuitBreaker>();

Singleton olmalÄ± âš ï¸

âœ… 3ï¸âƒ£ Middlewareâ€™e Entegrasyon

Constructorâ€™a ekliyoruz:

private readonly RedisCircuitBreaker _circuit;

public RedisIdempotencyMiddleware(
    RequestDelegate next,
    ILogger<RedisIdempotencyMiddleware> logger,
    RedisCircuitBreaker circuit)
{
    _next = next;
    _logger = logger;
    _circuit = circuit;
}
âœ… 4ï¸âƒ£ Cache + Lock Ã–ncesi Circuit KontrolÃ¼

Middleware baÅŸÄ±na ekle:

if (_circuit.IsOpen())
{
    _logger.LogWarning("Redis circuit OPEN. Bypassing Redis.");
    await _next(context);
    return;
}
âœ… 5ï¸âƒ£ Redis HatalarÄ±nda Circuit AÃ§

Ã–rneÄŸin GET sÄ±rasÄ±nda:

try
{
    cachedResponse = await store.GetAsync(idempotencyKey);
    _circuit.RecordSuccess();
}
catch (Exception ex)
{
    _logger.LogWarning(ex, "Redis GET failed.");
    _circuit.RecordFailure();
    await _next(context);
    return;
}

Lock kÄ±smÄ±nda da aynÄ± ÅŸekilde:

try
{
    lockValue = await store.AcquireAsyncLockWithLua(idempotencyKey, LockTtl);
    _circuit.RecordSuccess();
}
catch (Exception ex)
{
    _logger.LogWarning(ex, "Redis LOCK failed.");
    _circuit.RecordFailure();
    await _next(context);
    return;
}
ğŸ¯ Åimdi Ne Oldu?
Senaryo: Redis KapalÄ±

Ä°lk request:

Exception olur

Circuit OPEN olur

Controller Ã§alÄ±ÅŸÄ±r

Sonraki 30 saniye:

Redisâ€™e hiÃ§ dokunmaz

Exception oluÅŸmaz

Direkt controllerâ€™a gider

30 saniye sonra:

Yeniden Redis denenir

EÄŸer Ã§alÄ±ÅŸÄ±yorsa circuit kapanÄ±r

ğŸ§ª Test PlanÄ±

1ï¸âƒ£ Redisâ€™i kapat
2ï¸âƒ£ Request at

Log:

Redis GET failed
Redis circuit OPEN

3ï¸âƒ£ 10 request daha at

ArtÄ±k Redis exception logâ€™u gelmez.

4ï¸âƒ£ Redisâ€™i aÃ§
5ï¸âƒ£ 30 saniye bekle
6ï¸âƒ£ Request at

Circuit kapanÄ±r, Redis tekrar aktif olur.

ğŸ† Production KazanÄ±mÄ±
Problem	Ã‡Ã¶zÃ¼m
Redis down flood	Circuit breaker
Her request timeout	Ã–nlenir
False 409	Ã–nlenir
System availability	Artar
ğŸ”¥ ArtÄ±k Sistem Seviyesi

Åu anda mimarin:

DB unique = ultimate guard

Redis lock = concurrency control

Cache = replay

Circuit breaker = resilience

Fail-safe = degrade mode

Bu yapÄ± fintech production seviyesidir.

Ä°stersen bir Ã¼st seviyeye geÃ§elim:

ğŸ”¥ Distributed multi-instance API (multi pod)

ğŸ”¥ Redis cluster + failover

ğŸ”¥ Polly ile full resilience

ğŸ”¥ Stripe-level idempotency mimarisi